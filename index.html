<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* #background-canvas, */
        #canvas {
            cursor: grab;
            background-color: rgba(124, 124, 124, 0.1);
            border: 1px solid rgba(123, 0, 41, 0.5);
        }

        /* #background-canvas:active, */
        #canvas:active {
            cursor: grabbing;
        }

        #background-canvas,
        #canvas {
            position: absolute;
        }
    </style>
</head>

<body>
    <!-- <div style=""> -->
    <canvas id="background-canvas"></canvas>
    <canvas id="canvas"></canvas>
    <!-- <canvas id="second-canvas" width="320" height="320"></canvas> -->
    <!-- <canvas id="third-canvas" width="320" height="320"></canvas> -->
    <!-- </div> -->

    <script>
        function trimCanvas(c) {
            var ctx = c.getContext('2d'),
                copy = document.createElement('canvas').getContext('2d'),
                pixels = ctx.getImageData(0, 0, c.width, c.height),
                l = pixels.data.length,
                i,
                bound = {
                    top: null,
                    left: null,
                    right: null,
                    bottom: null
                },
                x, y;

            // Iterate over every pixel to find the highest
            // and where it ends on every axis ()
            for (i = 0; i < l; i += 4) {
                if (pixels.data[i + 3] !== 0) {
                    x = (i / 4) % c.width;
                    y = ~~((i / 4) / c.width);

                    if (bound.top === null) {
                        bound.top = y;
                    }

                    if (bound.left === null) {
                        bound.left = x;
                    } else if (x < bound.left) {
                        bound.left = x;
                    }

                    if (bound.right === null) {
                        bound.right = x;
                    } else if (bound.right < x) {
                        bound.right = x;
                    }

                    if (bound.bottom === null) {
                        bound.bottom = y;
                    } else if (bound.bottom < y) {
                        bound.bottom = y;
                    }
                }
            }

            // Calculate the height and width of the content
            var trimHeight = bound.bottom - bound.top,
                trimWidth = bound.right - bound.left,
                trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);

            copy.canvas.width = trimWidth;
            copy.canvas.height = trimHeight;
            copy.putImageData(trimmed, 0, 0);

            // Return trimmed canvas
            return copy.canvas;
        }

        const canvas = document.getElementById("canvas");
        const bgCanvas = document.getElementById("background-canvas");

        const ctx = canvas.getContext("2d",
            {
                willReadFrequently: true
            }
        );
        const bgCtx = bgCanvas.getContext("2d");

        const getCanvasOffset = (canvas) => canvas.getBoundingClientRect()

        const getCanvasPosition = (event, canvasOffset) => {
            return {
                x: Math.ceil(event.clientX - canvasOffset.left),
                y: Math.ceil(event.clientY - canvasOffset.top)
            }
        }

        let img = new Image();
        img.src = "res/inventory.png"

        let panningX = panningY = 0;

        const drawGrid = (context, gridWidth, gridHeight, gridCells) => {
            const gridCellSize = gridWidth / gridCells;

            context.strokeStyle = "rgba(123, 115, 69, 0.3)";

            for (let x = panningX % gridCellSize; x <= gridWidth; x += gridCellSize) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, gridHeight);

                context.imageSmoothingEnabled = false;
                context.stroke();
            }

            for (let y = panningY % gridCellSize; y <= gridHeight; y += gridCellSize) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(gridWidth, y);

                context.imageSmoothingEnabled = false;
                context.stroke();
            }
        }

        img.onload = () => {
            canvas.width = bgCanvas.width = img.width * 2;
            canvas.height = bgCanvas.height = img.height * 2;

            panningX = canvas.width / 3;
            panningY = canvas.height / 3;

            ctx.imageSmoothingEnabled = false;
            // ctx.drawImage(img, panningX, panningY);

            drawGrid(bgCtx, canvas.width, canvas.height, 8);
            // drawGrid(ctx, canvas.width, canvas.height, 8);
        }

        let canvasOffset = getCanvasOffset(canvas);

        let isMouseDown = false;
        let startX, startY;

        canvas.addEventListener('mousedown', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            isMouseDown = true;
            ({ x: startX, y: startY } = getCanvasPosition(e, getCanvasOffset(canvas)));
        })



        canvas.addEventListener('mousemove', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            if (isMouseDown) {
                panning(e, bgCanvas, bgCtx, () =>
                    drawGrid(bgCtx, canvas.width, canvas.height, 8)
                );

                // panning(e, canvas, ctx, () =>
                //     ctx.drawImage(img, panningX, panningY)
                // );

            } else return
        })

        const panning = (event, canvas, context, whatToDraw) => {
            const { x, y } = getCanvasPosition(event, getCanvasOffset(canvas));

            panningX += x - startX;
            panningY += y - startY;

            startX = x;
            startY = y;

            context.clearRect(0, 0, canvas.width, canvas.height);

            context.save();
            context.translate(panningX, panningY);
            context.restore();

            whatToDraw();
        }

        window.addEventListener('mouseup', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            isMouseDown = false;
        })


        canvas.addEventListener('mouseout', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            if (isMouseDown)
                isMouseDown = true;
        })

        window.onresize = (e) => {
            getCanvasOffset(canvas);
        }

        window.onscroll = (e) => {
            getCanvasOffset(canvas);
        }

    </script>
</body>

</html>