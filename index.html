<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* #background-canvas, */
        #canvas {
            cursor: grab;
            background-color: rgba(0, 0, 0, 0.05);
            border: 1px solid rgb(0, 0, 0);
        }

        /* #background-canvas:active, */
        #canvas:active {
            cursor: grabbing;
        }

        #background-canvas,
        #canvas {
            position: absolute;
        }
    </style>
</head>

<body>
    <canvas id="background-canvas"></canvas>
    <canvas id="canvas"></canvas>

    <script>
        function trimCanvas(c) {
            var ctx = c.getContext('2d'),
                copy = document.createElement('canvas').getContext('2d'),
                pixels = ctx.getImageData(0, 0, c.width, c.height),
                l = pixels.data.length,
                i,
                bound = {
                    top: null,
                    left: null,
                    right: null,
                    bottom: null
                },
                x, y;

            // Iterate over every pixel to find the highest
            // and where it ends on every axis ()
            for (i = 0; i < l; i += 4) {
                if (pixels.data[i + 3] !== 0) {
                    x = (i / 4) % c.width;
                    y = ~~((i / 4) / c.width);

                    if (bound.top === null) {
                        bound.top = y;
                    }

                    if (bound.left === null) {
                        bound.left = x;
                    } else if (x < bound.left) {
                        bound.left = x;
                    }

                    if (bound.right === null) {
                        bound.right = x;
                    } else if (bound.right < x) {
                        bound.right = x;
                    }

                    if (bound.bottom === null) {
                        bound.bottom = y;
                    } else if (bound.bottom < y) {
                        bound.bottom = y;
                    }
                }
            }

            // Calculate the height and width of the content
            var trimHeight = bound.bottom - bound.top,
                trimWidth = bound.right - bound.left,
                trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);

            copy.canvas.width = trimWidth;
            copy.canvas.height = trimHeight;
            copy.putImageData(trimmed, 0, 0);

            // Return trimmed canvas
            return copy.canvas;
        }

        const canvas = document.getElementById("canvas");
        const bgCanvas = document.getElementById("background-canvas");

        const ctx = canvas.getContext("2d",
            {
                willReadFrequently: true
            }
        );
        const bgCtx = bgCanvas.getContext("2d");

        const getCanvasOffset = (canvas) => canvas.getBoundingClientRect()

        const getCanvasPosition = (event, canvasOffset) => {
            return {
                x: Math.ceil(event.clientX - canvasOffset.left),
                y: Math.ceil(event.clientY - canvasOffset.top)
            }
        }

        let img = new Image();
        // img.src = "res/inventory_black.png"
        img.src = "res/inventory.png"

        let panningX = panningY = 0;
        let scale = 2;

        const drawGrid = (context, gridWidth, gridHeight, gridCells) => {
            const gridCellSize = gridWidth / gridCells;

            context.strokeStyle = "rgba(0, 0, 0, .1)";

            for (let x = panningX % gridCellSize; x <= gridWidth; x += gridCellSize) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, gridHeight);
                context.stroke();
            }

            for (let y = panningY % gridCellSize; y <= gridHeight; y += gridCellSize) {
                context.beginPath()
                context.moveTo(0, y);
                context.lineTo(gridWidth, y);
                context.stroke();
            }
        }

        img.onload = () => {
            canvas.width = bgCanvas.width = 700;
            canvas.height = bgCanvas.height = 700;

            panningX = canvas.width / 4;
            panningY = canvas.height / 4;

            ctx.imageSmoothingEnabled = false;
            ctx.save();
            ctx.scale(scale, scale);
            ctx.drawImage(img, panningX / scale, panningY / scale);
            ctx.restore();

            drawGrid(bgCtx, canvas.width, canvas.height, 8);
        }

        let canvasOffset = getCanvasOffset(canvas);

        let isMouseDown = false;
        let startX, startY;

        canvas.addEventListener('mousedown', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            isMouseDown = true;
            ({ x: startX, y: startY } = getCanvasPosition(e, getCanvasOffset(canvas)));
        })



        canvas.addEventListener('mousemove', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            if (isMouseDown) {
                panning(e, bgCanvas, bgCtx, () =>
                    drawGrid(bgCtx, canvas.width, canvas.height, 8)
                );

                // panning(e, canvas, ctx, () =>
                //     ctx.drawImage(img, panningX / 2, panningY / 2)
                // );
                // redraw(e, scale);

            } else return
        })

        const panning = (event, canvas, context, whatToDraw) => {
            const { x, y } = getCanvasPosition(event, getCanvasOffset(canvas));

            panningX += x - startX;
            panningY += y - startY;

            startX = x;
            startY = y;

            context.clearRect(0, 0, canvas.width, canvas.height);

            context.save();
            context.translate(panningX, panningY);
            context.restore();

            whatToDraw();
        }

        window.addEventListener('mouseup', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            isMouseDown = false;
        })


        canvas.addEventListener('mouseout', (e) => {
            // e.preventDefault();
            // e.stopPropagation();

            if (isMouseDown)
                isMouseDown = true;
        })

        canvas.addEventListener('wheel', (e) => {
            scale += event.deltaY * -0.01;

            scale = Math.min(Math.max(2, scale), 4);

            const { x, y } = getCanvasPosition(e, getCanvasOffset(canvas));

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save()
            ctx.scale(scale, scale);
            ctx.drawImage(img, (canvas.width / 4) / scale, (canvas.height / 4) / scale);
            ctx.restore()
        })

        window.onresize = (e) => {
            getCanvasOffset(canvas);
        }

        window.onscroll = (e) => {
            getCanvasOffset(canvas);
        }

    </script>
</body>

</html>